<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>GoPlus - Interactive Drone</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17"></script>

<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root { 
        --primary-color: #00FF47; --dark-color: #000502; --grid-color: rgba(0, 255, 71, 0.15);
        --glass-bg: rgba(0, 41, 15, 0.5); --glass-border: rgba(0, 255, 71, 0.2);
    }
    html, body {
        width: 100%;
        height: 100%;
        overflow: hidden; /* Предотвращает любой скролл на уровне body */
        touch-action: none; /* Отключает стандартные жесты браузера (скролл, зум) */
    }
    body { 
        background-color: var(--dark-color);
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: #eee;
    }
    .hero { 
        width: 100vw; height: 100vh; position: relative; overflow: hidden; 
        background: radial-gradient(ellipse at center, rgba(0, 26, 10, 0.5) 0%, var(--dark-color) 70%);
    }
    .hero::after {
        content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background-image: linear-gradient(var(--grid-color) 1px, transparent 1px), linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
        background-size: 50px 50px; opacity: 0.5; animation: pan-grid 20s linear infinite; z-index: 0;
    }
    @keyframes pan-grid { 0% { background-position: 0 0; } 100% { background-position: 50px 50px; } }
    .robot-img { width: 100%; height: 100%; cursor: grab; position: relative; z-index: 1; }
    #settings-toggle {
        position: fixed; bottom: 25px; right: 25px; width: 50px; height: 50px;
        background: var(--glass-bg); border: 1px solid var(--glass-border); border-radius: 50%;
        backdrop-filter: blur(10px); cursor: pointer; display: flex; align-items: center;
        justify-content: center; transition: background 0.3s, transform 0.3s; z-index: 100;
    }
    #settings-toggle:hover { background: rgba(0, 61, 22, 0.7); transform: scale(1.1); }
    #settings-toggle svg { width: 24px; height: 24px; fill: var(--primary-color); }
    
    /* --- СТИЛИ ПАНЕЛИ НАСТРОЕК (Общие) --- */
    #settings-panel {
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.95);
        width: 90vw; max-width: 800px;
        background: var(--glass-bg); border: 1px solid var(--glass-border);
        border-radius: 20px; backdrop-filter: blur(15px);
        padding: 25px; z-index: 99;
        opacity: 0; pointer-events: none;
        transition: opacity 0.4s, transform 0.4s;
        display: flex; flex-direction: column;
    }
    #settings-panel.active { opacity: 1; pointer-events: auto; transform: translate(-50%, -50%) scale(1); }
    
    .settings-content {
        /* Этот контейнер будет либо гридом, либо окном для свайпера */
        width: 100%;
    }

    /* --- Десктопный вид: ГРИД --- */
    .settings-grid { 
        display: grid; 
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); 
        gap: 20px; 
    }
    
    /* Скрываем элементы свайпера на десктопе */
    .swiper-container, .settings-dots {
        display: none;
    }
    
    .setting-card { background: rgba(0, 0, 0, 0.2); padding: 15px; border-radius: 10px; }
    .setting-card h3 { color: var(--primary-color); margin-bottom: 15px; font-size: 16px; letter-spacing: 0.5px; }
    .setting-control { margin-bottom: 10px; }
    .setting-control label { display: block; font-size: 13px; margin-bottom: 8px; opacity: 0.8; }
    
    input[type="range"] {
        -webkit-appearance: none; appearance: none;
        width: 100%; height: 6px; background: rgba(0, 255, 71, 0.2);
        border-radius: 3px; cursor: pointer; outline: none; padding: 0;
    }
    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none; appearance: none;
        width: 18px; height: 18px; background: var(--primary-color);
        border-radius: 50%; border: 2px solid var(--dark-color);
    }
    input[type="color"] { width: 100%; height: 30px; border: none; background: none; cursor: pointer; }
    .lil-gui.root { z-index: 101; }

    /* --- Мобильный вид: SWIPER --- */
    @media (max-width: 768px) {
        #settings-panel {
            padding: 20px 0 15px 0; /* Убираем боковые отступы, т.к. карточка их имеет */
        }
        
        /* Скрываем грид и показываем свайпер */
        .settings-grid { display: none; }
        .swiper-container { display: block; }
        
        .swiper-container {
            width: 100%;
            overflow: hidden; /* Самое важное: скрываем все, что не влезает */
        }
        
        #swiper-track {
            display: flex; /* Выстраиваем карточки в ряд */
            /* Плавный переход при "привязке" карточки после свайпа */
            transition: transform 0.3s ease-out; 
        }
        
        #swiper-track .setting-card {
            width: 85%; /* Каждая карточка занимает 85% ширины */
            flex-shrink: 0; /* Запрещаем карточкам сжиматься */
            margin: 0 7.5%; /* Центрируем карточку, оставляя по 7.5% с боков */
            touch-action: pan-y; /* Разрешаем вертикальный скролл внутри карточки, если он нужен */
            padding: 20px;
        }

        /* Навигационные точки */
        .settings-dots {
            display: flex;
            justify-content: center;
            align-items: center;
            padding-top: 15px;
        }
        .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: rgba(0, 255, 71, 0.3);
            margin: 0 5px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.3s;
        }
        .dot.active {
            background-color: var(--primary-color);
            transform: scale(1.3);
        }
    }
</style>
</head>
<body>

<section class="hero"><div class="robot-img" id="robot-container"></div></section>

<button id="settings-toggle"><svg viewBox="0 0 24 24"><path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.69-1.62-0.92L14.4,2.23c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.44,0.17-0.48,0.41L9.22,4.65C8.63,4.88,8.1,5.19,7.6,5.57L5.22,4.61C5,4.54,4.75,4.61,4.62,4.83L2.71,8.15 c-0.11,0.2-0.06,0.47,0.12,0.61l2.03,1.58C4.8,11.06,4.78,11.37,4.78,11.69c0,0.32,0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.69,1.62,0.92L9.6,21.77 c0.04,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.48-0.41l0.38-2.42c0.59-0.23,1.12-0.54,1.62-0.92l2.39,0.96 c0.22,0.08,0.47,0.01,0.59-0.22l1.92-3.32c0.11-0.2,0.06-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/></svg></button>

<!-- НОВАЯ СТРУКТУРА ПАНЕЛИ НАСТРОЕК -->
<div id="settings-panel">
    <div class="settings-content">
        <!-- Контейнер для десктопа (грид) -->
        <div class="settings-grid"></div>
        <!-- Контейнер для мобильных (свайпер) -->
        <div class="swiper-container">
            <div id="swiper-track"></div>
        </div>
    </div>
    <div class="settings-dots"></div>
</div>

<script>
// --- КОНФИГ И THREE.JS (без изменений) ---
const CONFIG = {
    robotScale: 8.5, followSpeed: 0.05, maxFollowAngle: 0.7, dragRotationSpeed: 0.007,
    inertiaMultiplier: 0.4, inertiaDamping: 0.98, velocityThreshold: 0.0001,
    levitationAmplitude: 0.15, levitationSpeed: 1.2, baseEmissive: 0.1, hoverEmissive: 0.2,
    ambientLight: 1.2, mainLight: 1.5, accentLight: 0.8, accentLightColor: '#00ff47',
    rings: { numRings: 3, color: '#00ff47', speed: 0.5, fadeSpeed: 2.0, fadeInDelay: 1000,
        topY: -1.0, bottomY: -2.0, baseOpacity: 0.7, baseIntensity: 1.5 }
};
const container = document.getElementById('robot-container');
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(container.clientWidth, container.clientHeight);
renderer.setPixelRatio(window.devicePixelRatio);
container.appendChild(renderer.domElement);
const ambientLight = new THREE.AmbientLight(0xffffff, CONFIG.ambientLight); scene.add(ambientLight);
const mainLight = new THREE.DirectionalLight(0xffffff, CONFIG.mainLight); mainLight.position.set(5, 10, 5); scene.add(mainLight);
const accentLight = new THREE.DirectionalLight(CONFIG.accentLightColor, CONFIG.accentLight); accentLight.position.set(-5, 5, -5); scene.add(accentLight);
let model, levitationRings = [];
const clock = new THREE.Clock();
const homeQuaternion = new THREE.Quaternion(), targetQuaternion = new THREE.Quaternion();
let isDragging = false, isMouseOver = false;
let angularVelocity = new THREE.Vector2(0, 0);
let previousMousePosition = { x: 0, y: 0 };
let ringsOpacityMultiplier = 1.; 
let inactiveStartTime = null;

// --- ЗАГРУЗКА И АНИМАЦИЯ (без изменений) ---
const loader = new THREE.GLTFLoader();
loader.load('model.glb', (gltf) => {
    model = gltf.scene;
    model.scale.set(CONFIG.robotScale, CONFIG.robotScale, CONFIG.robotScale);
    homeQuaternion.copy(model.quaternion);
    targetQuaternion.copy(model.quaternion);
    model.traverse((c) => { if (c.isMesh) { c.material.emissive = new THREE.Color(0x001a0a); c.material.emissiveIntensity = CONFIG.baseEmissive; } });
    scene.add(model);
    setupLevitationRings();
    setupSettingsPanel(); // <-- ИЗМЕНЕНО: Новая функция для создания настроек
    bindUiControls();
});
function setupLevitationRings() {
    levitationRings.forEach(ring => scene.remove(ring)); levitationRings = [];
    const h = CONFIG.rings.topY - CONFIG.rings.bottomY;
    for (let i = 0; i < CONFIG.rings.numRings; i++) {
        const ring = new THREE.Mesh(new THREE.TorusGeometry(0.9, 0.07, 16, 100), new THREE.MeshStandardMaterial({ color: CONFIG.rings.color, emissive: CONFIG.rings.color, transparent: true }));
        ring.rotation.x = Math.PI / 2; ring.position.y = CONFIG.rings.topY - (i * (h / CONFIG.rings.numRings));
        scene.add(ring); levitationRings.push(ring);
    }
}
camera.position.set(0, 0, 10);
function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta(), et = clock.getElapsedTime();
    if (model) {
        model.position.y = Math.sin(et * CONFIG.levitationSpeed) * CONFIG.levitationAmplitude;
        if (angularVelocity.lengthSq() > CONFIG.velocityThreshold) {
            const dr = new THREE.Quaternion().setFromEuler(new THREE.Euler(angularVelocity.y * dt * CONFIG.inertiaMultiplier, angularVelocity.x * dt * CONFIG.inertiaMultiplier, 0, 'XYZ'));
            model.quaternion.multiplyQuaternions(dr, model.quaternion);
            angularVelocity.multiplyScalar(CONFIG.inertiaDamping);
        } else {
            angularVelocity.set(0, 0); model.quaternion.slerp(targetQuaternion, CONFIG.followSpeed);
        }
    }
    const isInteractionActive = isDragging || angularVelocity.lengthSq() > CONFIG.velocityThreshold;
    if (isInteractionActive) {
        ringsOpacityMultiplier = Math.max(0, ringsOpacityMultiplier - CONFIG.rings.fadeSpeed * dt); inactiveStartTime = null; 
    } else {
        if (inactiveStartTime === null) inactiveStartTime = et;
        if (et - inactiveStartTime >= CONFIG.rings.fadeInDelay / 1000) {
            ringsOpacityMultiplier = Math.min(1, ringsOpacityMultiplier + CONFIG.rings.fadeSpeed * dt);
        }
    }
    const h = CONFIG.rings.topY - CONFIG.rings.bottomY;
    levitationRings.forEach(ring => {
        ring.position.y -= CONFIG.rings.speed * dt; if (ring.position.y < CONFIG.rings.bottomY) ring.position.y += h;
        let p = (ring.position.y - CONFIG.rings.bottomY) / h;
        ring.material.opacity = p * CONFIG.rings.baseOpacity * ringsOpacityMultiplier;
        ring.material.emissiveIntensity = p * CONFIG.rings.baseIntensity * ringsOpacityMultiplier;
        const s = 0.7 + (1 - p) * 0.5; ring.scale.set(s, s, s);
    });
    renderer.render(scene, camera);
}
animate();

// --- ОБРАБОТЧИКИ СОБЫТИЙ (без изменений) ---
function onPointerDown(e) { 
    isDragging = true; angularVelocity.set(0, 0); container.style.cursor = 'grabbing'; 
    previousMousePosition = { x: e.clientX || e.touches?.[0].clientX, y: e.clientY || e.touches?.[0].clientY }; 
}
function onPointerUp() { isDragging = false; container.style.cursor = 'grab'; }
function onPointerMove(e) {
    if (!model) return;
    const x = e.clientX || e.touches?.[0].clientX, y = e.clientY || e.touches?.[0].clientY;
    if (isDragging) {
        const dM = { x: x - previousMousePosition.x, y: y - previousMousePosition.y };
        const dR = new THREE.Quaternion().setFromEuler(new THREE.Euler(dM.y * CONFIG.dragRotationSpeed, dM.x * CONFIG.dragRotationSpeed, 0, 'XYZ'));
        model.quaternion.multiplyQuaternions(dR, model.quaternion);
        angularVelocity.set(dM.x, dM.y); previousMousePosition = { x, y };
    } else if (isMouseOver) {
        const r = container.getBoundingClientRect();
        targetQuaternion.setFromEuler(new THREE.Euler(((y-r.top)/r.height*2-1)*CONFIG.maxFollowAngle, ((x-r.left)/r.width*2-1)*CONFIG.maxFollowAngle,0,'XYZ'));
    }
}
container.addEventListener('mousedown', onPointerDown); window.addEventListener('mouseup', onPointerUp); window.addEventListener('mousemove', onPointerMove);
container.addEventListener('touchstart', (e)=>{onPointerDown(e);},{passive:true}); window.addEventListener('touchend',onPointerUp); window.addEventListener('touchmove',(e)=>{if(isDragging)onPointerMove(e);},{passive:true});
container.addEventListener('mouseenter', () => { isMouseOver = true; if(model)model.traverse(c=>{if(c.isMesh)c.material.emissiveIntensity=CONFIG.hoverEmissive;});});
container.addEventListener('mouseleave', () => { isMouseOver = false; targetQuaternion.copy(homeQuaternion); if(model)model.traverse(c=>{if(c.isMesh)c.material.emissiveIntensity=CONFIG.baseEmissive;});});
window.addEventListener('resize', () => { 
    camera.aspect = container.clientWidth/container.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(container.clientWidth,container.clientHeight);
    // Пересчитываем свайпер при изменении размера окна
    if (window.innerWidth <= 768) initSwiper();
});
const settingsToggle = document.getElementById('settings-toggle');
const settingsPanel = document.getElementById('settings-panel');
settingsToggle.addEventListener('click', () => { settingsPanel.classList.toggle('active'); });

// --- НОВЫЙ БЛОК: СОЗДАНИЕ ПАНЕЛИ НАСТРОЕК И ЛОГИКА СВАЙПЕРА ---

// 1. HTML-шаблоны для карточек настроек
const settingsHTML = `
    <div class="setting-card"><h3>Поведение</h3><div class="setting-control"><label for="followSpeed">Скорость слежения</label><input type="range" id="followSpeed" min="0.01" max="0.2" step="0.01"></div><div class="setting-control"><label for="maxFollowAngle">Угол обзора</label><input type="range" id="maxFollowAngle" min="0" max="1.5" step="0.1"></div></div>
    <div class="setting-card"><h3>Физика вращения</h3><div class="setting-control"><label for="dragSensitivity">Чувствительность</label><input type="range" id="dragSensitivity" min="0.005" max="0.05" step="0.001"></div><div class="setting-control"><label for="inertiaMultiplier">Множитель инерции</label><input type="range" id="inertiaMultiplier" min="0.01" max="1" step="0.01"></div><div class="setting-control"><label for="inertiaDamping">Затухание</label><input type="range" id="inertiaDamping" min="0.8" max="0.99" step="0.01"></div></div>
    <div class="setting-card"><h3>Левитация</h3><div class="setting-control"><label for="levitationAmplitude">Амплитуда</label><input type="range" id="levitationAmplitude" min="0" max="0.5" step="0.01"></div><div class="setting-control"><label for="levitationSpeed">Скорость</label><input type="range" id="levitationSpeed" min="0" max="3" step="0.1"></div></div>
    <div class="setting-card"><h3>Внешний вид</h3><div class="setting-control"><label for="robotScale">Масштаб</label><input type="range" id="robotScale" min="1" max="15" step="0.1"></div><div class="setting-control"><label for="mainLight">Основной свет</label><input type="range" id="mainLight" min="0" max="3" step="0.1"></div><div class="setting-control"><label for="accentLight">Акцентный свет</label><input type="range" id="accentLight" min="0" max="3" step="0.1"></div><div class="setting-control"><label for="accentLightColor">Цвет акцента</label><input type="color" id="accentLightColor"></div></div>
    <div class="setting-card"><h3>Кольца</h3><div class="setting-control"><label for="ringCount">Количество</label><input type="range" id="ringCount" min="1" max="10" step="1"></div><div class="setting-control"><label for="ringSpeed">Скорость</label><input type="range" id="ringSpeed" min="0.1" max="2" step="0.1"></div><div class="setting-control"><label for="ringFadeSpeed">Скорость затухания</label><input type="range" id="ringFadeSpeed" min="0.5" max="5" step="0.1"></div><div class="setting-control"><label for="ringFadeInDelay">Задержка появления (мс)</label><input type="range" id="ringFadeInDelay" min="0" max="5000" step="100"></div><div class="setting-control"><label for="ringColor">Цвет</label><input type="color" id="ringColor"></div></div>
`;

// 2. Функция, которая создает HTML
function setupSettingsPanel() {
    const gridContainer = document.querySelector('.settings-grid');
    const swiperTrack = document.getElementById('swiper-track');
    
    // Вставляем HTML в ОБА контейнера. CSS сам решит, какой показать.
    gridContainer.innerHTML = settingsHTML;
    swiperTrack.innerHTML = settingsHTML;

    // Создаем точки для свайпера
    const dotsContainer = document.querySelector('.settings-dots');
    const cards = swiperTrack.querySelectorAll('.setting-card');
    dotsContainer.innerHTML = ''; // Очищаем
    for (let i = 0; i < cards.length; i++) {
        const dot = document.createElement('div');
        dot.classList.add('dot');
        dot.addEventListener('click', () => {
            currentIndex = i;
            updateSwiperPosition();
        });
        dotsContainer.appendChild(dot);
    }
    
    // Инициализируем свайпер, если это мобильное устройство
    if (window.innerWidth <= 768) {
        initSwiper();
    }
}


// 3. Логика свайпера
let currentIndex = 0;
let isSwiping = false;
let startX = 0;
let currentTranslate = 0;

function initSwiper() {
    const swiperTrack = document.getElementById('swiper-track');
    
    // Сбрасываем все состояния
    currentIndex = 0;
    isSwiping = false;
    startX = 0;
    currentTranslate = 0;
    updateSwiperPosition();

    swiperTrack.addEventListener('touchstart', swipeStart, { passive: true });
    swiperTrack.addEventListener('touchmove', swipeMove, { passive: true });
    swiperTrack.addEventListener('touchend', swipeEnd);
}

function swipeStart(event) {
    startX = event.touches[0].clientX;
    isSwiping = true;
    // Отключаем анимацию на время свайпа
    document.getElementById('swiper-track').style.transition = 'none';
}

function swipeMove(event) {
    if (!isSwiping) return;
    const currentX = event.touches[0].clientX;
    const diff = currentX - startX;
    // Двигаем трек вслед за пальцем
    const trackWidth = document.getElementById('swiper-track').scrollWidth;
    const containerWidth = document.querySelector('.swiper-container').offsetWidth;
    // Базовый сдвиг для текущего слайда + сдвиг пальцем
    const baseTranslate = -currentIndex * containerWidth;
    currentTranslate = baseTranslate + diff;
    
    document.getElementById('swiper-track').style.transform = `translateX(${currentTranslate}px)`;
}

function swipeEnd() {
    if (!isSwiping) return;
    isSwiping = false;
    // Включаем анимацию для плавного "доведения"
    document.getElementById('swiper-track').style.transition = 'transform 0.3s ease-out';
    
    const diff = currentTranslate - (-currentIndex * document.querySelector('.swiper-container').offsetWidth);
    const cardCount = document.querySelectorAll('#swiper-track .setting-card').length;

    // Если свайпнули достаточно далеко, меняем слайд
    if (diff < -50 && currentIndex < cardCount - 1) {
        currentIndex++;
    } else if (diff > 50 && currentIndex > 0) {
        currentIndex--;
    }
    
    updateSwiperPosition();
}

function updateSwiperPosition() {
    const containerWidth = document.querySelector('.swiper-container').offsetWidth;
    const newTranslate = -currentIndex * containerWidth;
    document.getElementById('swiper-track').style.transform = `translateX(${newTranslate}px)`;
    
    // Обновляем активную точку
    const dots = document.querySelectorAll('.dot');
    dots.forEach((dot, index) => {
        dot.classList.toggle('active', index === currentIndex);
    });
}


// 4. Привязка контролов (как и раньше, но вызывается после создания HTML)
function bindUiControls() {
    const controls = {
        'followSpeed':(v)=>CONFIG.followSpeed=parseFloat(v),'maxFollowAngle':(v)=>CONFIG.maxFollowAngle=parseFloat(v),
        'dragSensitivity':(v)=>CONFIG.dragRotationSpeed=parseFloat(v),'inertiaMultiplier':(v)=>CONFIG.inertiaMultiplier=parseFloat(v),'inertiaDamping':(v)=>CONFIG.inertiaDamping=parseFloat(v),
        'levitationAmplitude':(v)=>CONFIG.levitationAmplitude=parseFloat(v),'levitationSpeed':(v)=>CONFIG.levitationSpeed=parseFloat(v),
        'robotScale':(v)=>{CONFIG.robotScale=parseFloat(v);model?.scale.set(v,v,v);},
        'mainLight':(v)=>mainLight.intensity=parseFloat(v),'accentLight':(v)=>accentLight.intensity=parseFloat(v),'accentLightColor':(v)=>accentLight.color.set(v),
        'ringCount':{event:'change',handler:(v)=>{CONFIG.rings.numRings=parseInt(v);setupLevitationRings();}},
        'ringSpeed':(v)=>CONFIG.rings.speed=parseFloat(v),'ringFadeSpeed':(v)=>CONFIG.rings.fadeSpeed=parseFloat(v),'ringFadeInDelay':(v)=>CONFIG.rings.fadeInDelay=parseInt(v),
        'ringColor':(v)=>{CONFIG.rings.color=v;levitationRings.forEach(r=>{r.material.color.set(v);r.material.emissive.set(v);});}
    };
    
    const initControlValue = (id) => {
        const elements = document.querySelectorAll('#' + id); // Ищем контролы в обоих контейнерах
        if (elements.length === 0) return;
        let value;
        if(id.startsWith('ring')){const k=id.charAt(4).toLowerCase()+id.slice(5);value=CONFIG.rings[k];}
        else if(id==='dragSensitivity'){value=CONFIG.dragRotationSpeed;}else{value=CONFIG[id];}
        elements.forEach(el => {
            if(el.type==='range'&&value!==undefined)el.value=value;
            if(el.type==='color'&&value!==undefined)el.value=value;
        });
    };
    
    for (const id in controls) {
        initControlValue(id);
        const elements = document.querySelectorAll('#' + id);
        elements.forEach(el => {
            const eventType = typeof controls[id]==='object'?controls[id].event:'input';
            const handler = typeof controls[id]==='object'?controls[id].handler:controls[id];
            el.addEventListener(eventType, e => handler(e.target.value));
        });
    }
}
// --- GUI (без изменений) ---
const gui = new lil.GUI(); gui.hide(); window.addEventListener('keydown', (e) => { if (e.key.toLowerCase() === 'd') gui.show(gui._hidden); });
</script>
</body>
</html>